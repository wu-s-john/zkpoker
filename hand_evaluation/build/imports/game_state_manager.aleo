import room_manager.aleo;
import dealer.aleo;
program game_state_manager.aleo;

struct Permutation:
    perm1 as [u8; 26u32];
    perm2 as [u8; 26u32];

record PlayerProposedShuffle:
    owner as address.private;
    room_id as u32.private;
    seat_index as u8.private;
    seat_owner as address.private;
    dealer_nonce as u64.private;
    perm as Permutation.private;
    player_randomness as scalar.private;

record PlayerActionResponse:
    owner as address.private;
    seat_index as u8.private;
    room_id as u32.private;
    stack as u64.private;
    nonce as u64.private;
    contributed as u64.private;
    action_type as u8.private;
    amount as u64.private;

struct Card:
    rank as u8;
    suit as u8;
    index as u8;

struct Player:
    player_address as address;
    stack as u64;
    contributed as u64;
    folded as boolean;
    all_in as boolean;

record GameState:
    owner as address.private;
    num_players as u8.private;
    house_dealer_actor as address.private;
    dealer_seat as u8.private;
    small_blind_seat as u8.private;
    big_blind_seat as u8.private;
    small_blind as u64.private;
    big_blind as u64.private;
    room_id as u32.private;
    current_phase as u8.private;
    community_cards as [Card; 5u32].private;
    players as [Player; 4u32].private;
    nonce as u64.private;
    highest_bet as u64.private;
    main_pot as u64.private;
    active_player_turn_index as u8.private;
    has_acted_this_round as u8.private;

record PlayerActionRequest:
    owner as address.private;
    seat_index as u8.private;
    room_id as u32.private;
    nonce as u64.private;
    stack as u64.private;
    contributed as u64.private;
    highest_bet as u64.private;
    main_pot as u64.private;

struct PlayerRoomConfig:
    player_address as address;
    bet as u64;

struct RoomConfig:
    big_blind as u64;
    big_blind_seat as u8;
    small_blind as u64;
    small_blind_seat as u8;
    dealer_seat as u8;
    min_stack as u64;
    seats as u8;
    room_id as u32;
    joined_users as [PlayerRoomConfig; 4u32];
    num_joined_users as u8;
    game_state_manager_address as address;

struct Deck:
    cards1 as [Card; 26u32];
    cards2 as [Card; 26u32];

struct HouseDealerState:
    room_id as u32;
    deck as Deck;
    next_card_index as u8;
    player_addresses as [address; 4u32];

struct KeyValue:
    k as u8;
    v as u8;

struct PermutatedTable:
    perm1 as [KeyValue; 26u32];
    perm2 as [KeyValue; 26u32];

function player_propose_shuffle:
    input r0 as Permutation.private;
    input r1 as dealer.aleo/HouseDealerShuffleRequest.record;
    is.eq r1.owner self.caller into r2;
    assert.eq r2 true;
    shl 1u64 r0.perm1[0u32] into r3;
    or 0u64 r3 into r4;
    shl 1u64 r0.perm2[0u32] into r5;
    or r4 r5 into r6;
    shl 1u64 r0.perm1[1u32] into r7;
    or r6 r7 into r8;
    shl 1u64 r0.perm2[1u32] into r9;
    or r8 r9 into r10;
    shl 1u64 r0.perm1[2u32] into r11;
    or r10 r11 into r12;
    shl 1u64 r0.perm2[2u32] into r13;
    or r12 r13 into r14;
    shl 1u64 r0.perm1[3u32] into r15;
    or r14 r15 into r16;
    shl 1u64 r0.perm2[3u32] into r17;
    or r16 r17 into r18;
    shl 1u64 r0.perm1[4u32] into r19;
    or r18 r19 into r20;
    shl 1u64 r0.perm2[4u32] into r21;
    or r20 r21 into r22;
    shl 1u64 r0.perm1[5u32] into r23;
    or r22 r23 into r24;
    shl 1u64 r0.perm2[5u32] into r25;
    or r24 r25 into r26;
    shl 1u64 r0.perm1[6u32] into r27;
    or r26 r27 into r28;
    shl 1u64 r0.perm2[6u32] into r29;
    or r28 r29 into r30;
    shl 1u64 r0.perm1[7u32] into r31;
    or r30 r31 into r32;
    shl 1u64 r0.perm2[7u32] into r33;
    or r32 r33 into r34;
    shl 1u64 r0.perm1[8u32] into r35;
    or r34 r35 into r36;
    shl 1u64 r0.perm2[8u32] into r37;
    or r36 r37 into r38;
    shl 1u64 r0.perm1[9u32] into r39;
    or r38 r39 into r40;
    shl 1u64 r0.perm2[9u32] into r41;
    or r40 r41 into r42;
    shl 1u64 r0.perm1[10u32] into r43;
    or r42 r43 into r44;
    shl 1u64 r0.perm2[10u32] into r45;
    or r44 r45 into r46;
    shl 1u64 r0.perm1[11u32] into r47;
    or r46 r47 into r48;
    shl 1u64 r0.perm2[11u32] into r49;
    or r48 r49 into r50;
    shl 1u64 r0.perm1[12u32] into r51;
    or r50 r51 into r52;
    shl 1u64 r0.perm2[12u32] into r53;
    or r52 r53 into r54;
    shl 1u64 r0.perm1[13u32] into r55;
    or r54 r55 into r56;
    shl 1u64 r0.perm2[13u32] into r57;
    or r56 r57 into r58;
    shl 1u64 r0.perm1[14u32] into r59;
    or r58 r59 into r60;
    shl 1u64 r0.perm2[14u32] into r61;
    or r60 r61 into r62;
    shl 1u64 r0.perm1[15u32] into r63;
    or r62 r63 into r64;
    shl 1u64 r0.perm2[15u32] into r65;
    or r64 r65 into r66;
    shl 1u64 r0.perm1[16u32] into r67;
    or r66 r67 into r68;
    shl 1u64 r0.perm2[16u32] into r69;
    or r68 r69 into r70;
    shl 1u64 r0.perm1[17u32] into r71;
    or r70 r71 into r72;
    shl 1u64 r0.perm2[17u32] into r73;
    or r72 r73 into r74;
    shl 1u64 r0.perm1[18u32] into r75;
    or r74 r75 into r76;
    shl 1u64 r0.perm2[18u32] into r77;
    or r76 r77 into r78;
    shl 1u64 r0.perm1[19u32] into r79;
    or r78 r79 into r80;
    shl 1u64 r0.perm2[19u32] into r81;
    or r80 r81 into r82;
    shl 1u64 r0.perm1[20u32] into r83;
    or r82 r83 into r84;
    shl 1u64 r0.perm2[20u32] into r85;
    or r84 r85 into r86;
    shl 1u64 r0.perm1[21u32] into r87;
    or r86 r87 into r88;
    shl 1u64 r0.perm2[21u32] into r89;
    or r88 r89 into r90;
    shl 1u64 r0.perm1[22u32] into r91;
    or r90 r91 into r92;
    shl 1u64 r0.perm2[22u32] into r93;
    or r92 r93 into r94;
    shl 1u64 r0.perm1[23u32] into r95;
    or r94 r95 into r96;
    shl 1u64 r0.perm2[23u32] into r97;
    or r96 r97 into r98;
    shl 1u64 r0.perm1[24u32] into r99;
    or r98 r99 into r100;
    shl 1u64 r0.perm2[24u32] into r101;
    or r100 r101 into r102;
    shl 1u64 r0.perm1[25u32] into r103;
    or r102 r103 into r104;
    shl 1u64 r0.perm2[25u32] into r105;
    or r104 r105 into r106;
    is.eq r106 0u64 into r107;
    assert.eq r107 true;
    cast self.caller r1.room_id r1.seat_index self.caller 0u64 r0 0scalar into r108 as PlayerProposedShuffle.record;
    output r108 as PlayerProposedShuffle.record;

function start_game:
    input r0 as room_manager.aleo/RoomConfigRequest.record;
    input r1 as address.private;
    cast r0.room_config.joined_users[0u32].player_address r0.room_config.joined_users[0u32].bet 0u64 false false into r2 as Player;
    cast r0.room_config.joined_users[1u32].player_address r0.room_config.joined_users[1u32].bet 0u64 false false into r3 as Player;
    cast r0.room_config.joined_users[2u32].player_address r0.room_config.joined_users[2u32].bet 0u64 false false into r4 as Player;
    cast r0.room_config.joined_users[3u32].player_address r0.room_config.joined_users[3u32].bet 0u64 false false into r5 as Player;
    cast  r2 r3 r4 r5 into r6 as [Player; 4u32];
    cast 13u8 13u8 52u8 into r7 as Card;
    cast  r7 r7 r7 r7 r7 into r8 as [Card; 5u32];
    add r0.room_config.big_blind_seat 1u8 into r9;
    rem r9 r0.room_config.num_joined_users into r10;
    cast r0.room_config.game_state_manager_address r0.room_config.num_joined_users r1 r0.room_config.dealer_seat r0.room_config.small_blind_seat r0.room_config.big_blind_seat r0.room_config.small_blind r0.room_config.big_blind r0.room_config.room_id 0u8 r8 r6 0u64 0u64 0u64 r10 0u8 into r11 as GameState.record;
    is.eq r11.active_player_turn_index 0u8 into r12;
    not r12 into r13;
    is.eq r11.active_player_turn_index 1u8 into r14;
    and r13 r14 into r15;
    not r14 into r16;
    is.eq r11.active_player_turn_index 2u8 into r17;
    and r13 r16 into r18;
    and r18 r17 into r19;
    not r17 into r20;
    and r18 r20 into r21;
    ternary r19 r11.players[2u32].player_address r11.players[3u32].player_address into r22;
    ternary r19 r11.players[2u32].stack r11.players[3u32].stack into r23;
    ternary r19 r11.players[2u32].contributed r11.players[3u32].contributed into r24;
    ternary r19 r11.players[2u32].folded r11.players[3u32].folded into r25;
    ternary r19 r11.players[2u32].all_in r11.players[3u32].all_in into r26;
    cast r22 r23 r24 r25 r26 into r27 as Player;
    ternary r15 r11.players[1u32].player_address r27.player_address into r28;
    ternary r15 r11.players[1u32].stack r27.stack into r29;
    ternary r15 r11.players[1u32].contributed r27.contributed into r30;
    ternary r15 r11.players[1u32].folded r27.folded into r31;
    ternary r15 r11.players[1u32].all_in r27.all_in into r32;
    cast r28 r29 r30 r31 r32 into r33 as Player;
    ternary r12 r11.players[0u32].player_address r33.player_address into r34;
    ternary r12 r11.players[0u32].stack r33.stack into r35;
    ternary r12 r11.players[0u32].contributed r33.contributed into r36;
    ternary r12 r11.players[0u32].folded r33.folded into r37;
    ternary r12 r11.players[0u32].all_in r33.all_in into r38;
    cast r34 r35 r36 r37 r38 into r39 as Player;
    cast r39.player_address r11.active_player_turn_index r11.room_id r11.nonce r39.stack r39.contributed r11.highest_bet r11.main_pot into r40 as PlayerActionRequest.record;
    output r11 as GameState.record;
    output r40 as PlayerActionRequest.record;

function player_submit_action:
    input r0 as PlayerActionRequest.record;
    input r1 as u8.private;
    input r2 as u64.private;
    is.eq r1 0u8 into r3;
    is.eq r2 0u64 into r4;
    not r3 into r5;
    or r4 r5 into r6;
    assert.eq r6 true;
    not r3 into r7;
    is.eq r1 1u8 into r8;
    sub r0.highest_bet r0.contributed into r9;
    is.eq r2 r9 into r10;
    lte r2 r0.stack into r11;
    and r10 r11 into r12;
    and r7 r8 into r13;
    not r13 into r14;
    or r12 r14 into r15;
    assert.eq r15 true;
    not r8 into r16;
    is.eq r1 2u8 into r17;
    add r2 r0.contributed into r18;
    gt r18 r0.highest_bet into r19;
    lte r2 r0.stack into r20;
    and r19 r20 into r21;
    and r7 r16 into r22;
    and r22 r17 into r23;
    not r23 into r24;
    or r21 r24 into r25;
    assert.eq r25 true;
    not r17 into r26;
    is.eq r1 3u8 into r27;
    lt 0u64 r2 into r28;
    is.eq r2 r0.stack into r29;
    and r28 r29 into r30;
    and r22 r26 into r31;
    and r31 r27 into r32;
    not r32 into r33;
    or r30 r33 into r34;
    assert.eq r34 true;
    not r27 into r35;
    and r31 r35 into r36;
    not r36 into r37;
    or false r37 into r38;
    assert.eq r38 true;
    sub r0.stack r2 into r39;
    add r0.contributed r2 into r40;
    cast self.caller r0.seat_index r0.room_id r39 r0.nonce r40 r1 r2 into r41 as PlayerActionResponse.record;
    output r41 as PlayerActionResponse.record;

function gsm_process_action_next_betting:
    input r0 as GameState.record;
    input r1 as PlayerActionResponse.record;
    is.eq r0.room_id r1.room_id into r2;
    assert.eq r2 true;
    lt r1.seat_index r0.num_players into r3;
    assert.eq r3 true;
    is.eq r0.nonce r1.nonce into r4;
    assert.eq r4 true;
    add r0.nonce 1u64 into r5;
    add r1.seat_index 1u8 into r6;
    rem r6 4u8 into r7;
    shr r0.has_acted_this_round r7 into r8;
    and r8 1u8 into r9;
    is.eq r9 0u8 into r10;
    add r7 1u8 into r11;
    rem r11 4u8 into r12;
    shr r0.has_acted_this_round r12 into r13;
    and r13 1u8 into r14;
    is.eq r14 0u8 into r15;
    add r12 1u8 into r16;
    rem r16 4u8 into r17;
    shr r0.has_acted_this_round r17 into r18;
    and r18 1u8 into r19;
    is.eq r19 0u8 into r20;
    add r17 1u8 into r21;
    rem r21 4u8 into r22;
    shr r0.has_acted_this_round r22 into r23;
    and r23 1u8 into r24;
    is.eq r24 0u8 into r25;
    add r22 1u8 into r26;
    rem r26 4u8 into r27;
    ternary r25 r22 4u8 into r28;
    ternary r20 r17 r28 into r29;
    ternary r15 r12 r29 into r30;
    ternary r10 r7 r30 into r31;
    lt r31 4u8 into r32;
    assert.eq r32 true;
    shl 1u8 r1.seat_index into r33;
    or r0.has_acted_this_round r33 into r34;
    is.eq r1.seat_index 0u8 into r35;
    is.eq r1.action_type 3u8 into r36;
    is.eq r1.action_type 0u8 into r37;
    cast r0.players[0u32].player_address r1.stack r1.contributed r37 r36 into r38 as Player;
    ternary r35 r38.player_address r0.players[0u32].player_address into r39;
    ternary r35 r38.stack r0.players[0u32].stack into r40;
    ternary r35 r38.contributed r0.players[0u32].contributed into r41;
    ternary r35 r38.folded r0.players[0u32].folded into r42;
    ternary r35 r38.all_in r0.players[0u32].all_in into r43;
    cast r39 r40 r41 r42 r43 into r44 as Player;
    is.eq r1.seat_index 1u8 into r45;
    is.eq r1.action_type 3u8 into r46;
    is.eq r1.action_type 0u8 into r47;
    cast r0.players[1u32].player_address r1.stack r1.contributed r47 r46 into r48 as Player;
    ternary r45 r48.player_address r0.players[1u32].player_address into r49;
    ternary r45 r48.stack r0.players[1u32].stack into r50;
    ternary r45 r48.contributed r0.players[1u32].contributed into r51;
    ternary r45 r48.folded r0.players[1u32].folded into r52;
    ternary r45 r48.all_in r0.players[1u32].all_in into r53;
    cast r49 r50 r51 r52 r53 into r54 as Player;
    is.eq r1.seat_index 2u8 into r55;
    is.eq r1.action_type 3u8 into r56;
    is.eq r1.action_type 0u8 into r57;
    cast r0.players[2u32].player_address r1.stack r1.contributed r57 r56 into r58 as Player;
    ternary r55 r58.player_address r0.players[2u32].player_address into r59;
    ternary r55 r58.stack r0.players[2u32].stack into r60;
    ternary r55 r58.contributed r0.players[2u32].contributed into r61;
    ternary r55 r58.folded r0.players[2u32].folded into r62;
    ternary r55 r58.all_in r0.players[2u32].all_in into r63;
    cast r59 r60 r61 r62 r63 into r64 as Player;
    is.eq r1.seat_index 3u8 into r65;
    is.eq r1.action_type 3u8 into r66;
    is.eq r1.action_type 0u8 into r67;
    cast r0.players[3u32].player_address r1.stack r1.contributed r67 r66 into r68 as Player;
    ternary r65 r68.player_address r0.players[3u32].player_address into r69;
    ternary r65 r68.stack r0.players[3u32].stack into r70;
    ternary r65 r68.contributed r0.players[3u32].contributed into r71;
    ternary r65 r68.folded r0.players[3u32].folded into r72;
    ternary r65 r68.all_in r0.players[3u32].all_in into r73;
    cast r69 r70 r71 r72 r73 into r74 as Player;
    cast  r44 r54 r64 r74 into r75 as [Player; 4u32];
    add r0.main_pot r1.amount into r76;
    add r1.amount r1.stack into r77;
    gte r0.highest_bet r77 into r78;
    not r78 into r79;
    ternary r78 r0.highest_bet r77 into r80;
    is.eq r31 0u8 into r81;
    not r81 into r82;
    is.eq r31 1u8 into r83;
    and r82 r83 into r84;
    not r83 into r85;
    is.eq r31 2u8 into r86;
    and r82 r85 into r87;
    and r87 r86 into r88;
    not r86 into r89;
    and r87 r89 into r90;
    ternary r88 r0.players[2u32].player_address r0.players[3u32].player_address into r91;
    ternary r88 r0.players[2u32].stack r0.players[3u32].stack into r92;
    ternary r88 r0.players[2u32].contributed r0.players[3u32].contributed into r93;
    ternary r88 r0.players[2u32].folded r0.players[3u32].folded into r94;
    ternary r88 r0.players[2u32].all_in r0.players[3u32].all_in into r95;
    cast r91 r92 r93 r94 r95 into r96 as Player;
    ternary r84 r0.players[1u32].player_address r96.player_address into r97;
    ternary r84 r0.players[1u32].stack r96.stack into r98;
    ternary r84 r0.players[1u32].contributed r96.contributed into r99;
    ternary r84 r0.players[1u32].folded r96.folded into r100;
    ternary r84 r0.players[1u32].all_in r96.all_in into r101;
    cast r97 r98 r99 r100 r101 into r102 as Player;
    ternary r81 r0.players[0u32].player_address r102.player_address into r103;
    ternary r81 r0.players[0u32].stack r102.stack into r104;
    ternary r81 r0.players[0u32].contributed r102.contributed into r105;
    ternary r81 r0.players[0u32].folded r102.folded into r106;
    ternary r81 r0.players[0u32].all_in r102.all_in into r107;
    cast r103 r104 r105 r106 r107 into r108 as Player;
    cast r0.owner r0.num_players r0.house_dealer_actor r0.dealer_seat r0.small_blind_seat r0.big_blind_seat r0.small_blind r0.big_blind r0.room_id r0.current_phase r0.community_cards r75 r5 r80 r76 r31 r34 into r109 as GameState.record;
    cast r108.player_address r31 r0.room_id r5 r108.stack r108.contributed r80 r76 into r110 as PlayerActionRequest.record;
    output r109 as GameState.record;
    output r110 as PlayerActionRequest.record;

function gsm_advance_phase_flop:
    input r0 as GameState.record;
    input r1 as dealer.aleo/DealtThreeCommunityCards.record;
    input r2 as PlayerActionResponse.record;
    is.eq r0.current_phase 0u8 into r3;
    assert.eq r3 true;
    add r2.seat_index 1u8 into r4;
    rem r4 4u8 into r5;
    shr r0.has_acted_this_round r5 into r6;
    and r6 1u8 into r7;
    is.eq r7 0u8 into r8;
    add r5 1u8 into r9;
    rem r9 4u8 into r10;
    shr r0.has_acted_this_round r10 into r11;
    and r11 1u8 into r12;
    is.eq r12 0u8 into r13;
    add r10 1u8 into r14;
    rem r14 4u8 into r15;
    shr r0.has_acted_this_round r15 into r16;
    and r16 1u8 into r17;
    is.eq r17 0u8 into r18;
    add r15 1u8 into r19;
    rem r19 4u8 into r20;
    shr r0.has_acted_this_round r20 into r21;
    and r21 1u8 into r22;
    is.eq r22 0u8 into r23;
    add r20 1u8 into r24;
    rem r24 4u8 into r25;
    ternary r23 r20 4u8 into r26;
    ternary r18 r15 r26 into r27;
    ternary r13 r10 r27 into r28;
    ternary r8 r5 r28 into r29;
    is.eq r29 4u8 into r30;
    assert.eq r30 true;
    cast  r1.cards[0u32] r1.cards[1u32] r1.cards[2u32] r0.community_cards[3u32] r0.community_cards[4u32] into r31 as [Card; 5u32];
    add r0.nonce 1u64 into r32;
    add r0.big_blind_seat 1u8 into r33;
    rem r33 r0.num_players into r34;
    add r0.big_blind_seat 2u8 into r35;
    rem r35 r0.num_players into r36;
    add r0.big_blind_seat 3u8 into r37;
    rem r37 r0.num_players into r38;
    cast  r0.big_blind_seat r34 r36 r38 into r39 as [u8; 4u32];
    is.neq r39[0u32] 0u8 into r40;
    shl 1u8 r39[0u32] into r41;
    or 0u8 r41 into r42;
    ternary r40 r42 0u8 into r43;
    is.neq r39[1u32] 0u8 into r44;
    shl 1u8 r39[1u32] into r45;
    or r43 r45 into r46;
    ternary r44 r46 r43 into r47;
    is.neq r39[2u32] 0u8 into r48;
    shl 1u8 r39[2u32] into r49;
    or r47 r49 into r50;
    ternary r48 r50 r47 into r51;
    is.neq r39[3u32] 0u8 into r52;
    shl 1u8 r39[3u32] into r53;
    or r51 r53 into r54;
    ternary r52 r54 r51 into r55;
    shl 1u8 4u8 into r56;
    sub r56 1u8 into r57;
    shl r57 r0.dealer_seat into r58;
    and r58 15u8 into r59;
    and r55 r59 into r60;
    is.neq r60 0u8 into r61;
    and r60 1u8 into r62;
    is.neq r62 0u8 into r63;
    and r60 2u8 into r64;
    is.neq r64 0u8 into r65;
    and r60 4u8 into r66;
    is.neq r66 0u8 into r67;
    and r60 8u8 into r68;
    is.neq r68 0u8 into r69;
    ternary r69 3u8 0u8 into r70;
    ternary r67 2u8 r70 into r71;
    ternary r65 1u8 r71 into r72;
    ternary r63 0u8 r72 into r73;
    shl 1u8 r0.dealer_seat into r74;
    sub r74 1u8 into r75;
    and r75 15u8 into r76;
    and r55 r76 into r77;
    and r77 1u8 into r78;
    is.neq r78 0u8 into r79;
    and r77 2u8 into r80;
    is.neq r80 0u8 into r81;
    and r77 4u8 into r82;
    is.neq r82 0u8 into r83;
    and r77 8u8 into r84;
    is.neq r84 0u8 into r85;
    ternary r85 3u8 0u8 into r86;
    ternary r83 2u8 r86 into r87;
    ternary r81 1u8 r87 into r88;
    ternary r79 0u8 r88 into r89;
    ternary r61 r73 r89 into r90;
    xor r55 15u8 into r91;
    cast r0.owner r0.num_players r0.house_dealer_actor r0.dealer_seat r0.small_blind_seat r0.big_blind_seat r0.small_blind r0.big_blind r0.room_id 1u8 r31 r0.players r32 r0.highest_bet r0.main_pot r90 r91 into r92 as GameState.record;
    is.eq r90 0u8 into r93;
    not r93 into r94;
    is.eq r90 1u8 into r95;
    and r94 r95 into r96;
    not r95 into r97;
    is.eq r90 2u8 into r98;
    and r94 r97 into r99;
    and r99 r98 into r100;
    not r98 into r101;
    and r99 r101 into r102;
    ternary r100 r92.players[2u32].player_address r92.players[3u32].player_address into r103;
    ternary r100 r92.players[2u32].stack r92.players[3u32].stack into r104;
    ternary r100 r92.players[2u32].contributed r92.players[3u32].contributed into r105;
    ternary r100 r92.players[2u32].folded r92.players[3u32].folded into r106;
    ternary r100 r92.players[2u32].all_in r92.players[3u32].all_in into r107;
    cast r103 r104 r105 r106 r107 into r108 as Player;
    ternary r96 r92.players[1u32].player_address r108.player_address into r109;
    ternary r96 r92.players[1u32].stack r108.stack into r110;
    ternary r96 r92.players[1u32].contributed r108.contributed into r111;
    ternary r96 r92.players[1u32].folded r108.folded into r112;
    ternary r96 r92.players[1u32].all_in r108.all_in into r113;
    cast r109 r110 r111 r112 r113 into r114 as Player;
    ternary r93 r92.players[0u32].player_address r114.player_address into r115;
    ternary r93 r92.players[0u32].stack r114.stack into r116;
    ternary r93 r92.players[0u32].contributed r114.contributed into r117;
    ternary r93 r92.players[0u32].folded r114.folded into r118;
    ternary r93 r92.players[0u32].all_in r114.all_in into r119;
    cast r115 r116 r117 r118 r119 into r120 as Player;
    cast r120.player_address r90 r92.room_id r32 r120.stack r120.contributed r92.highest_bet r92.main_pot into r121 as PlayerActionRequest.record;
    output r92 as GameState.record;
    output r121 as PlayerActionRequest.record;

function gsm_advance_phase_turn_river:
    input r0 as GameState.record;
    input r1 as dealer.aleo/DealtOneCommunityCard.record;
    input r2 as PlayerActionResponse.record;
    input r3 as boolean.private;
    is.eq r0.current_phase 1u8 into r4;
    is.eq r0.current_phase 2u8 into r5;
    ternary r3 r4 r5 into r6;
    assert.eq r6 true;
    add r2.seat_index 1u8 into r7;
    rem r7 4u8 into r8;
    shr r0.has_acted_this_round r8 into r9;
    and r9 1u8 into r10;
    is.eq r10 0u8 into r11;
    add r8 1u8 into r12;
    rem r12 4u8 into r13;
    shr r0.has_acted_this_round r13 into r14;
    and r14 1u8 into r15;
    is.eq r15 0u8 into r16;
    add r13 1u8 into r17;
    rem r17 4u8 into r18;
    shr r0.has_acted_this_round r18 into r19;
    and r19 1u8 into r20;
    is.eq r20 0u8 into r21;
    add r18 1u8 into r22;
    rem r22 4u8 into r23;
    shr r0.has_acted_this_round r23 into r24;
    and r24 1u8 into r25;
    is.eq r25 0u8 into r26;
    add r23 1u8 into r27;
    rem r27 4u8 into r28;
    ternary r26 r23 4u8 into r29;
    ternary r21 r18 r29 into r30;
    ternary r16 r13 r30 into r31;
    ternary r11 r8 r31 into r32;
    is.eq r32 4u8 into r33;
    assert.eq r33 true;
    cast  r0.community_cards[0u32] r0.community_cards[1u32] r0.community_cards[2u32] r1.card r0.community_cards[4u32] into r34 as [Card; 5u32];
    add r0.nonce 1u64 into r35;
    add r0.big_blind_seat 1u8 into r36;
    rem r36 r0.num_players into r37;
    add r0.big_blind_seat 2u8 into r38;
    rem r38 r0.num_players into r39;
    add r0.big_blind_seat 3u8 into r40;
    rem r40 r0.num_players into r41;
    cast  r0.big_blind_seat r37 r39 r41 into r42 as [u8; 4u32];
    is.neq r42[0u32] 0u8 into r43;
    shl 1u8 r42[0u32] into r44;
    or 0u8 r44 into r45;
    ternary r43 r45 0u8 into r46;
    is.neq r42[1u32] 0u8 into r47;
    shl 1u8 r42[1u32] into r48;
    or r46 r48 into r49;
    ternary r47 r49 r46 into r50;
    is.neq r42[2u32] 0u8 into r51;
    shl 1u8 r42[2u32] into r52;
    or r50 r52 into r53;
    ternary r51 r53 r50 into r54;
    is.neq r42[3u32] 0u8 into r55;
    shl 1u8 r42[3u32] into r56;
    or r54 r56 into r57;
    ternary r55 r57 r54 into r58;
    shl 1u8 4u8 into r59;
    sub r59 1u8 into r60;
    shl r60 r0.dealer_seat into r61;
    and r61 15u8 into r62;
    and r58 r62 into r63;
    is.neq r63 0u8 into r64;
    and r63 1u8 into r65;
    is.neq r65 0u8 into r66;
    and r63 2u8 into r67;
    is.neq r67 0u8 into r68;
    and r63 4u8 into r69;
    is.neq r69 0u8 into r70;
    and r63 8u8 into r71;
    is.neq r71 0u8 into r72;
    ternary r72 3u8 0u8 into r73;
    ternary r70 2u8 r73 into r74;
    ternary r68 1u8 r74 into r75;
    ternary r66 0u8 r75 into r76;
    shl 1u8 r0.dealer_seat into r77;
    sub r77 1u8 into r78;
    and r78 15u8 into r79;
    and r58 r79 into r80;
    and r80 1u8 into r81;
    is.neq r81 0u8 into r82;
    and r80 2u8 into r83;
    is.neq r83 0u8 into r84;
    and r80 4u8 into r85;
    is.neq r85 0u8 into r86;
    and r80 8u8 into r87;
    is.neq r87 0u8 into r88;
    ternary r88 3u8 0u8 into r89;
    ternary r86 2u8 r89 into r90;
    ternary r84 1u8 r90 into r91;
    ternary r82 0u8 r91 into r92;
    ternary r64 r76 r92 into r93;
    add r0.current_phase 1u8 into r94;
    cast r0.owner r0.num_players r0.house_dealer_actor r0.dealer_seat r0.small_blind_seat r0.big_blind_seat r0.small_blind r0.big_blind r0.room_id r94 r34 r0.players r35 r0.highest_bet r0.main_pot r93 r58 into r95 as GameState.record;
    is.eq r93 0u8 into r96;
    not r96 into r97;
    is.eq r93 1u8 into r98;
    and r97 r98 into r99;
    not r98 into r100;
    is.eq r93 2u8 into r101;
    and r97 r100 into r102;
    and r102 r101 into r103;
    not r101 into r104;
    and r102 r104 into r105;
    ternary r103 r95.players[2u32].player_address r95.players[3u32].player_address into r106;
    ternary r103 r95.players[2u32].stack r95.players[3u32].stack into r107;
    ternary r103 r95.players[2u32].contributed r95.players[3u32].contributed into r108;
    ternary r103 r95.players[2u32].folded r95.players[3u32].folded into r109;
    ternary r103 r95.players[2u32].all_in r95.players[3u32].all_in into r110;
    cast r106 r107 r108 r109 r110 into r111 as Player;
    ternary r99 r95.players[1u32].player_address r111.player_address into r112;
    ternary r99 r95.players[1u32].stack r111.stack into r113;
    ternary r99 r95.players[1u32].contributed r111.contributed into r114;
    ternary r99 r95.players[1u32].folded r111.folded into r115;
    ternary r99 r95.players[1u32].all_in r111.all_in into r116;
    cast r112 r113 r114 r115 r116 into r117 as Player;
    ternary r96 r95.players[0u32].player_address r117.player_address into r118;
    ternary r96 r95.players[0u32].stack r117.stack into r119;
    ternary r96 r95.players[0u32].contributed r117.contributed into r120;
    ternary r96 r95.players[0u32].folded r117.folded into r121;
    ternary r96 r95.players[0u32].all_in r117.all_in into r122;
    cast r118 r119 r120 r121 r122 into r123 as Player;
    cast r123.player_address r93 r95.room_id r35 r123.stack r123.contributed r95.highest_bet r95.main_pot into r124 as PlayerActionRequest.record;
    output r95 as GameState.record;
    output r124 as PlayerActionRequest.record;

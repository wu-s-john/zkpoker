import room_manager.aleo;
import dealer.aleo;
import game_state_manager.aleo;
program hand_evaluation.aleo;

struct Card:
    rank as u8;
    suit as u8;
    index as u8;

record FinalHand:
    owner as address.private;
    seat_index as u8.private;
    did_fold as boolean.private;
    final_score as u32.private;
    player_hand as [Card; 2u32].private;

record PlayerFinalHandRequest:
    owner as address.private;
    room_id as u32.private;
    seat_index as u8.private;
    did_fold as boolean.private;

struct PlayerRoomConfig:
    player_address as address;
    bet as u64;

struct RoomConfig:
    big_blind as u64;
    big_blind_seat as u8;
    small_blind as u64;
    small_blind_seat as u8;
    dealer_seat as u8;
    min_stack as u64;
    seats as u8;
    room_id as u32;
    joined_users as [PlayerRoomConfig; 4u32];
    num_joined_users as u8;
    game_state_manager_address as address;

struct Deck:
    cards1 as [Card; 26u32];
    cards2 as [Card; 26u32];

struct HouseDealerState:
    room_id as u32;
    deck as Deck;
    next_card_index as u8;
    player_addresses as [address; 4u32];

struct Permutation:
    perm1 as [u8; 26u32];
    perm2 as [u8; 26u32];

struct KeyValue:
    k as u8;
    v as u8;

struct PermutatedTable:
    perm1 as [KeyValue; 26u32];
    perm2 as [KeyValue; 26u32];

struct Player:
    player_address as address;
    stack as u64;
    contributed as u64;
    folded as boolean;
    all_in as boolean;

function player_show_winning_hand:
    input r0 as PlayerFinalHandRequest.record;
    input r1 as [Card; 2u32].private;
    input r2 as [Card; 5u32].private;
    input r3 as [Card; 7u32].private;
    input r4 as u8.private;
    cast r0.owner r0.seat_index true 0u32 r1 into r5 as FinalHand.record;
    lte r4 9u8 into r6;
    or r6 r0.did_fold into r7;
    assert.eq r7 true;
    is.eq r4 9u8 into r8;
    is.eq r3[0u32].rank 14u8 into r9;
    not r8 into r10;
    or r9 r10 into r11;
    or r11 r0.did_fold into r12;
    assert.eq r12 true;
    is.eq r3[1u32].rank 13u8 into r13;
    not r8 into r14;
    or r13 r14 into r15;
    or r15 r0.did_fold into r16;
    assert.eq r16 true;
    is.eq r3[2u32].rank 12u8 into r17;
    not r8 into r18;
    or r17 r18 into r19;
    or r19 r0.did_fold into r20;
    assert.eq r20 true;
    is.eq r3[3u32].rank 11u8 into r21;
    not r8 into r22;
    or r21 r22 into r23;
    or r23 r0.did_fold into r24;
    assert.eq r24 true;
    is.eq r3[4u32].rank 10u8 into r25;
    not r8 into r26;
    or r25 r26 into r27;
    or r27 r0.did_fold into r28;
    assert.eq r28 true;
    not r8 into r29;
    is.eq r4 8u8 into r30;
    add r3[0u32].rank 1u8 into r31;
    is.eq r31 r3[1u32].rank into r32;
    add r3[0u32].rank 2u8 into r33;
    is.eq r33 r3[1u32].rank into r34;
    or r32 r34 into r35;
    add r3[0u32].rank 3u8 into r36;
    is.eq r36 r3[1u32].rank into r37;
    or r35 r37 into r38;
    add r3[0u32].rank 4u8 into r39;
    is.eq r39 r3[1u32].rank into r40;
    or r38 r40 into r41;
    and r29 r30 into r42;
    not r42 into r43;
    or r41 r43 into r44;
    or r44 r0.did_fold into r45;
    assert.eq r45 true;
    not r30 into r46;
    is.eq r4 7u8 into r47;
    is.eq r3[0u32].rank r3[1u32].rank into r48;
    and r29 r46 into r49;
    and r49 r47 into r50;
    not r50 into r51;
    or r48 r51 into r52;
    or r52 r0.did_fold into r53;
    assert.eq r53 true;
    is.eq r3[0u32].rank r3[2u32].rank into r54;
    not r50 into r55;
    or r54 r55 into r56;
    or r56 r0.did_fold into r57;
    assert.eq r57 true;
    is.eq r3[0u32].rank r3[3u32].rank into r58;
    not r50 into r59;
    or r58 r59 into r60;
    or r60 r0.did_fold into r61;
    assert.eq r61 true;
    not r47 into r62;
    is.eq r4 6u8 into r63;
    is.eq r3[0u32].rank r3[1u32].rank into r64;
    and r49 r62 into r65;
    and r65 r63 into r66;
    not r66 into r67;
    or r64 r67 into r68;
    or r68 r0.did_fold into r69;
    assert.eq r69 true;
    is.eq r3[0u32].rank r3[2u32].rank into r70;
    not r66 into r71;
    or r70 r71 into r72;
    or r72 r0.did_fold into r73;
    assert.eq r73 true;
    is.eq r3[3u32].rank r3[4u32].rank into r74;
    not r66 into r75;
    or r74 r75 into r76;
    or r76 r0.did_fold into r77;
    assert.eq r77 true;
    not r63 into r78;
    is.eq r4 5u8 into r79;
    is.eq r3[1u32].suit r3[0u32].suit into r80;
    and r65 r78 into r81;
    and r81 r79 into r82;
    not r82 into r83;
    or r80 r83 into r84;
    or r84 r0.did_fold into r85;
    assert.eq r85 true;
    is.eq r3[2u32].suit r3[0u32].suit into r86;
    not r82 into r87;
    or r86 r87 into r88;
    or r88 r0.did_fold into r89;
    assert.eq r89 true;
    is.eq r3[3u32].suit r3[0u32].suit into r90;
    not r82 into r91;
    or r90 r91 into r92;
    or r92 r0.did_fold into r93;
    assert.eq r93 true;
    is.eq r3[4u32].suit r3[0u32].suit into r94;
    not r82 into r95;
    or r94 r95 into r96;
    or r96 r0.did_fold into r97;
    assert.eq r97 true;
    not r79 into r98;
    is.eq r4 4u8 into r99;
    sub r3[0u32].rank 1u8 into r100;
    is.eq r3[1u32].rank r100 into r101;
    and r81 r98 into r102;
    and r102 r99 into r103;
    not r103 into r104;
    or r101 r104 into r105;
    or r105 r0.did_fold into r106;
    assert.eq r106 true;
    sub r3[0u32].rank 2u8 into r107;
    is.eq r3[2u32].rank r107 into r108;
    not r103 into r109;
    or r108 r109 into r110;
    or r110 r0.did_fold into r111;
    assert.eq r111 true;
    sub r3[0u32].rank 3u8 into r112;
    is.eq r3[3u32].rank r112 into r113;
    not r103 into r114;
    or r113 r114 into r115;
    or r115 r0.did_fold into r116;
    assert.eq r116 true;
    sub r3[0u32].rank 4u8 into r117;
    is.eq r3[4u32].rank r117 into r118;
    not r103 into r119;
    or r118 r119 into r120;
    or r120 r0.did_fold into r121;
    assert.eq r121 true;
    not r99 into r122;
    is.eq r4 3u8 into r123;
    is.eq r3[1u32].rank r3[0u32].rank into r124;
    and r102 r122 into r125;
    and r125 r123 into r126;
    not r126 into r127;
    or r124 r127 into r128;
    or r128 r0.did_fold into r129;
    assert.eq r129 true;
    is.eq r3[2u32].rank r3[0u32].rank into r130;
    not r126 into r131;
    or r130 r131 into r132;
    or r132 r0.did_fold into r133;
    assert.eq r133 true;
    not r123 into r134;
    is.eq r4 2u8 into r135;
    is.eq r3[1u32].rank r3[0u32].rank into r136;
    and r125 r134 into r137;
    and r137 r135 into r138;
    not r138 into r139;
    or r136 r139 into r140;
    or r140 r0.did_fold into r141;
    assert.eq r141 true;
    is.eq r3[3u32].rank r3[2u32].rank into r142;
    not r138 into r143;
    or r142 r143 into r144;
    or r144 r0.did_fold into r145;
    assert.eq r145 true;
    not r135 into r146;
    is.eq r4 1u8 into r147;
    is.eq r3[1u32].rank r3[0u32].rank into r148;
    and r137 r146 into r149;
    and r149 r147 into r150;
    not r150 into r151;
    or r148 r151 into r152;
    or r152 r0.did_fold into r153;
    assert.eq r153 true;
    cast r4 into r154 as u32;
    shl r154 20u32 into r155;
    cast r3[0u32].rank into r156 as u32;
    shl r156 16u32 into r157;
    add r155 r157 into r158;
    cast r3[1u32].rank into r159 as u32;
    shl r159 12u32 into r160;
    add r158 r160 into r161;
    cast r3[2u32].rank into r162 as u32;
    shl r162 8u32 into r163;
    add r161 r163 into r164;
    cast r3[3u32].rank into r165 as u32;
    shl r165 4u32 into r166;
    add r164 r166 into r167;
    cast r3[4u32].rank into r168 as u32;
    shl r168 0u32 into r169;
    add r167 r169 into r170;
    cast self.caller r0.seat_index false r170 r1 into r171 as FinalHand.record;
    ternary r0.did_fold r5.owner r171.owner into r172;
    ternary r0.did_fold r5.seat_index r171.seat_index into r173;
    ternary r0.did_fold r5.did_fold r171.did_fold into r174;
    ternary r0.did_fold r5.final_score r171.final_score into r175;
    ternary r0.did_fold r5.player_hand[0u32].rank r171.player_hand[0u32].rank into r176;
    ternary r0.did_fold r5.player_hand[0u32].suit r171.player_hand[0u32].suit into r177;
    ternary r0.did_fold r5.player_hand[0u32].index r171.player_hand[0u32].index into r178;
    cast r176 r177 r178 into r179 as Card;
    ternary r0.did_fold r5.player_hand[1u32].rank r171.player_hand[1u32].rank into r180;
    ternary r0.did_fold r5.player_hand[1u32].suit r171.player_hand[1u32].suit into r181;
    ternary r0.did_fold r5.player_hand[1u32].index r171.player_hand[1u32].index into r182;
    cast r180 r181 r182 into r183 as Card;
    cast  r179 r183 into r184 as [Card; 2u32];
    cast r172 r173 r174 r175 r184 into r185 as FinalHand.record;
    output r185 as FinalHand.record;

function gsm_determine_winner:
    input r0 as FinalHand.record;
    input r1 as FinalHand.record;
    input r2 as FinalHand.record;
    input r3 as FinalHand.record;
    gte r0.final_score r1.final_score into r4;
    assert.eq r4 true;
    gte r1.final_score r2.final_score into r5;
    assert.eq r5 true;
    gte r2.final_score r3.final_score into r6;
    assert.eq r6 true;
    lt r0.seat_index 4u8 into r7;
    assert.eq r7 true;
    lt r1.seat_index 4u8 into r8;
    assert.eq r8 true;
    lt r2.seat_index 4u8 into r9;
    assert.eq r9 true;
    lt r3.seat_index 4u8 into r10;
    assert.eq r10 true;
    cast  r0.seat_index r1.seat_index r2.seat_index r3.seat_index into r11 as [u8; 4u32];
    shl 1u8 r11[0u32] into r12;
    and 0u8 r12 into r13;
    is.eq r13 0u8 into r14;
    assert.eq r14 true;
    or 0u8 r12 into r15;
    shl 1u8 r11[1u32] into r16;
    and r15 r16 into r17;
    is.eq r17 0u8 into r18;
    assert.eq r18 true;
    or r15 r16 into r19;
    shl 1u8 r11[2u32] into r20;
    and r19 r20 into r21;
    is.eq r21 0u8 into r22;
    assert.eq r22 true;
    or r19 r20 into r23;
    shl 1u8 r11[3u32] into r24;
    and r23 r24 into r25;
    is.eq r25 0u8 into r26;
    assert.eq r26 true;
    or r23 r24 into r27;
    is.eq r27 15u8 into r28;
    assert.eq r28 true;
    is.eq r1.final_score r0.final_score into r29;
    ternary r29 r1.seat_index 4u8 into r30;
    is.eq r2.final_score r0.final_score into r31;
    ternary r31 r2.seat_index 4u8 into r32;
    is.eq r3.final_score r0.final_score into r33;
    ternary r33 r3.seat_index 4u8 into r34;
    cast  r0.seat_index r30 r32 r34 into r35 as [u8; 4u32];
    output r35 as [u8; 4u32].private;
